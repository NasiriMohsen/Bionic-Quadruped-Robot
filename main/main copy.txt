#include "Gyro.h"
#include "Quadruped.h"

MPU6050Handler mpuHandler;

String input = "down";

float lastPitchError = 0.0;
float lastRollError = 0.0;
float Ipitch = 0.0;
float Iroll = 0.0;

void setup() {
    Serial.begin(115200);

    Setup_Legs();
    Flat();
    delay(1000);

    if (!mpuHandler.begin()) {
        Serial.println("Failed to initialize MPU6050.");
        while (1);
    }

    Serial.println("Calibrating MPU6050...");
    mpuHandler.calibrate();
    Serial.println("Calibration complete!");
}

void loop() {
  float pitch, roll;
  mpuHandler.getAngles(pitch, roll);

  Serial.print("Pitch: ");
  Serial.println(pitch);
  Serial.print("Â°, Roll: ");
  Serial.println(roll);

  if (Serial.available() > 0) {
    input = Serial.readString();
    input.trim();
  }
  if (input == "run") {
//------------------------------------------------- 
    float pitchError = 0 - pitch;
    float rollError = 0 - roll;

    float pitchCorrection = 0;
    float rollCorrection = 0;

    float Kp = 0; 

    float Kd = 0;
    float Dpitch = (pitchError - lastPitchError) / 0.1; 
    float Droll = (rollError - lastRollError) / 0.1;

    float Ki = 0;
    Ipitch += pitchError * 0.1; 
    Iroll += rollError * 0.1;   

    pitchCorrection = Kp * pitchError + Ki * Ipitch + Kd * Dpitch;
    rollCorrection = Kp * rollError + Ki * Iroll + Kd * Droll;

    lastPitchError = pitchError;
    lastRollError = rollError;

    Front_Right(Hip_Default_angle, Hostile_angle - pitchCorrection + rollCorrection);
    Front_Left(Hip_Default_angle, Hostile_angle - pitchCorrection - rollCorrection);
    Back_Right(Hip_Default_angle, Hostile_angle + pitchCorrection + rollCorrection);
    Back_Left(Hip_Default_angle, Hostile_angle + pitchCorrection - rollCorrection);
    delay(100);
//-------------------------------------------------
  } else if (input == "down"){
    Flat();
  } else if (input == "normal"){
    Normal();
  } else if (input == "compressed"){
    Compressed();
  } else if (input == "nll"){
    Normal_Lean_Left();
  } else if (input == "nlr"){
    Normal_Lean_Right();
  } else if (input == "nlf"){
    Normal_Lean_Front();
  } else if (input == "nlb"){
    Normal_Lean_Back();
  } else if (input == "hpbr"){
    Hostile_Point_BR();
  } else if (input == "hpfr"){
    Hostile_Point_FR();
  } else if (input == "hpfl"){
    Hostile_Point_FL();
  } else if (input == "hpbl"){
    Hostile_Point_BL();
  } else if (input == "npbr"){
    Normal_Point_BR();
  } else if (input == "npfr"){
    Normal_Point_FR();
  } else if (input == "npfl"){
    Normal_Point_FL();
  } else if (input == "npbl"){
    Normal_Point_BL();
  } else if (input == "tlhr"){
    Turn_Left_Hostile_R(100);
  } else if (input == "trhr"){
    Turn_Right_Hostile_R(100);
  } else if (input == "tlhl"){
    Turn_Left_Hostile_L(100);
  } else if (input == "trhl"){
    Turn_Right_Hostile_L(100);
  } else if (input == "tlnr"){
    Turn_Left_Normal_R(100);
  } else if (input == "trnr"){
    Turn_Right_Normal_R(100);
  } else if (input == "tlnl"){
    Turn_Left_Normal_L(100);
  } else if (input == "trnl"){
    Turn_Right_Normal_L(100);
  } else if (input == "chill"){
    Toggle_Motors();
    input = "";
  } else {
    Hostile();
  }
}
